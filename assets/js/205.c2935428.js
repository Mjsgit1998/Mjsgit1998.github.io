(window.webpackJsonp=window.webpackJsonp||[]).push([[205],{520:function(t,a,e){"use strict";e.r(a);var s=e(7),n=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-setstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-setstate"}},[t._v("#")]),t._v(" 1. setState")]),t._v(" "),a("h3",{attrs:{id:"setstate更新状态的2种写法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate更新状态的2种写法"}},[t._v("#")]),t._v(" setState更新状态的2种写法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\t(1). setState(stateChange, [callback])------对象式的setState\n            1.stateChange为状态改变对象(该对象可以体现出状态的更改)\n            2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用\n\t\t\t\t\t\n\t(2). setState(updater, [callback])------函数式的setState\n            1.updater为返回stateChange对象的函数。\n            2.updater可以接收到state和props。\n            4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。\n总结:\n\t\t1.对象式的setState是函数式的setState的简写方式(语法糖)\n\t\t2.使用原则：\n\t\t\t\t(1).如果新状态不依赖于原状态 ===> 使用对象方式\n\t\t\t\t(2).如果新状态依赖于原状态 ===> 使用函数方式\n\t\t\t\t(3).如果需要在setState()执行后获取最新的状态数据, \n\t\t\t\t\t要在第二个callback函数中读取\n")])])]),a("hr"),t._v(" "),a("h2",{attrs:{id:"_2-lazyload"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-lazyload"}},[t._v("#")]),t._v(" 2. lazyLoad")]),t._v(" "),a("h3",{attrs:{id:"路由组件的lazyload"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由组件的lazyload"}},[t._v("#")]),t._v(" 路由组件的lazyLoad")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//1.通过React的lazy函数配合import()函数动态加载路由组件 ===> 路由组件代码会被分开打包")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Login "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("lazy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@/pages/Login'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//2.通过<Suspense>指定在加载得到路由打包文件前显示一个自定义loading界面")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Suspense fallback"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("h1"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("loading"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("h1"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Switch"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Route path"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/xxx"')]),t._v(" component"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("Xxxx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Redirect to"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/login"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Switch"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Suspense"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("hr"),t._v(" "),a("h2",{attrs:{id:"_3-hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-hooks"}},[t._v("#")]),t._v(" 3. Hooks")]),t._v(" "),a("h4",{attrs:{id:"_1-react-hook-hooks是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-react-hook-hooks是什么"}},[t._v("#")]),t._v(" 1. React Hook/Hooks是什么?")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("(1). Hook是React 16.8.0版本增加的新特性/新语法\n(2). 可以让你在函数组件中使用 state 以及其他的 React 特性\n")])])]),a("h4",{attrs:{id:"_2-三个常用的hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-三个常用的hook"}},[t._v("#")]),t._v(" 2. 三个常用的Hook")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("(1). State Hook: React.useState()\n(2). Effect Hook: React.useEffect()\n(3). Ref Hook: React.useRef()\n")])])]),a("h4",{attrs:{id:"_3-state-hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-state-hook"}},[t._v("#")]),t._v(" 3. State Hook")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作\n(2). 语法: const [xxx, setXxx] = React.useState(initValue)  \n(3). useState()说明:\n        参数: 第一次初始化指定的值在内部作缓存\n        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数 \n(4). setXxx()2种写法:\n        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值\n        setXxx(value => newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值\n")])])]),a("h4",{attrs:{id:"_4-effect-hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-effect-hook"}},[t._v("#")]),t._v(" 4. Effect Hook")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)\n(2). React中的副作用操作:\n        发ajax请求数据获取\n        设置订阅 / 启动定时器\n        手动更改真实DOM\n(3). 语法和说明: \n\t\tconst judeg = useRef(false)\n        useEffect(() => { \n          // 在此可以执行任何带副作用操作\n          // ！！！在react 18 版本中 ，此处逻辑会执行两次。可以使用useRef来定义一个量来控制。\n          if(!judeg.current){\n              judeg.current = true\n              XXXXXXX\n          }\n          \n          return () => { // 在组件卸载前执行\n            // 在此做一些收尾工作, 比如清除定时器/取消订阅等\n          }\n        }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行\n    \n(4). 可以把 useEffect Hook 看做如下三个函数的组合\n        componentDidMount()\n        componentDidUpdate()\n    \tcomponentWillUnmount() \n")])])]),a("h4",{attrs:{id:"_5-ref-hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-ref-hook"}},[t._v("#")]),t._v(" 5. Ref Hook")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据\n(2). 语法: const refContainer = useRef()\n(3). 作用:保存标签对象,功能与React.createRef()一样\n")])])]),a("h4",{attrs:{id:"_6-usereducer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-usereducer"}},[t._v("#")]),t._v(" "),a("strong",[t._v("6.useReducer")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 功能基本和usestate一样，就是对数据可以进行多种处理\n\nconst [state,dispatch]= useReducer(reducer,initialState,setInitialState)\n\n(1)reducer就是对数据的多种处理\n(2)initialState为state的初始值\n(3)setInitialState为一个函数就是对initialState这个初始值进行处理，其返回值作为state的初始\t 值，也可以没有这个参数。\n\nfunction reducer(state,{type}){\n\tswitch(type){\n\t\tcase 'increment':\n\t\t\treturn {number:state.number +1}\n\t\tcase 'decrement':\n\t\t\treturn {number:state.number - 1}\n\t\tdefault:\n\t\t\tthrow new Error()\n\t}\n}\n\nconst initialState = {\n \tnumber : 0\n}\n\nconst setInitialState = (initialState)=>{\n\treturn {...initialState,age:222}\n}\n\n// 在组件中使用\n<div onClick={()=>{dispatch({type:'increment'})}}> + </div>\n\n")])])]),a("h4",{attrs:{id:"_7-forwardref-useref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-forwardref-useref"}},[t._v("#")]),t._v(" 7.forwardRef，useRef")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("功能是让父组件可以获取到函数式子组件的ref实例。\nforwardRef 可以在父组件中操作子组件的 ref 对象\nforwardRef 可以将父组件中的 ref 对象转发到子组件中的 dom 元素上\n子组件接受 props 和 ref 作为参数\n\nconst Father = ()=>{\n\tlet childRef = useRef()\n\tconsole.log(childRef.current)\n\treturn (\n\t\t<Child ref={childRef}/>\n\t)\n}\nconst Child = (props,fatherref)=>(<input ref={fatherref}/>)\nChild = forwardRef(Child)\n")])])]),a("h4",{attrs:{id:"_8-useimperativehandle-forwardref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-useimperativehandle-forwardref"}},[t._v("#")]),t._v(" 8.useImperativeHandle,forwardRef")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("在子组件中使用，自定义要暴露给父组件的ref，与forwardRef一起使用。\n第一个参数是父组件的ref，第二个参数为函数，返回值是父组件可以获取到的东西\n\nconst Child = (props,parentRef)=>{\n\tlet inputRef1 = useRef()\n\tlet inputRef2 = useRef()\n\tuseImperativeHandle(parentRef,()=>{\n\t\treturn {\n\t\t\tinputRef1,\n\t\t\tinputRef2,\n\t\t\tfocus(){\n\t\t\t\tinputRef1.current.focus()\n\t\t\t},\n\t\t\tchangtext(text){\n\t\t\t\tinputRef2.current.value = text\n\t\t\t}\n\t\t}\n\t})\n\treturn (\n\t\t<>\n\t\t\t<input ref={inputRef1}/>\n\t\t\t<input ref={inputRef2}/>\n\t\t</>\n\t)\n}\n\nChild = forwardRef(Child)\n\nconst Father = ()=>{\n\tlet parentRef = useRef()\n\tconsole.log(parentRef.current.XXXX) 在这里可以获取到子组件传过来的ref\n\treturn(\n\t\t<Child ref={parentRef}/>\n\t)\n}\n\n")])])]),a("h4",{attrs:{id:"_9-usecontext"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-usecontext"}},[t._v("#")]),t._v(" 9.useContext")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("在子组件中使用，用来获取provider传的值。\n\nlet Mycontext = React.createContext()\n\n\nlet data = useContext(Mycontext)\n")])])]),a("hr"),t._v(" "),a("h2",{attrs:{id:"_4-fragment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-fragment"}},[t._v("#")]),t._v(" 4. Fragment")]),t._v(" "),a("h3",{attrs:{id:"使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("<Fragment><Fragment>\n<></>\n")])])]),a("h3",{attrs:{id:"作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),a("blockquote",[a("p",[t._v("可以不用必须有一个真实的DOM根标签了")])]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"_5-context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-context"}},[t._v("#")]),t._v(" 5. Context")]),t._v(" "),a("h3",{attrs:{id:"理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#理解"}},[t._v("#")]),t._v(" 理解")]),t._v(" "),a("blockquote",[a("p",[t._v("一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信")])]),t._v(" "),a("h3",{attrs:{id:"使用-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-2"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 创建Context容器对象：\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" XxxContext "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createContext")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  \n\t\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 渲染子组时，外面包裹xxxContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Provider"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 通过value属性给后代组件传递数据：\n\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("xxxContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Provider value"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("数据"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t\t子组件\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("xxxContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Provider"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 后代组件读取数据：\n\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//第一种方式:仅适用于类组件 ")]),t._v("\n\t  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" contextType "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" xxxContext  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 声明接收context")]),t._v("\n\t  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("context "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 读取context中的value数据")]),t._v("\n\t  \n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//第二种方式: 函数组件与类组件都可以")]),t._v("\n\t  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("xxxContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Consumer"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t      "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("value")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// value就是context中的value数据")]),t._v("\n\t        要显示的内容\n\t      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("xxxContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Consumer"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第三种方式hook ： 函数式组件")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" data "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useContext")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("XXXContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//可以读取到provider传过来的值")]),t._v("\n\t\n\t\n")])])]),a("h3",{attrs:{id:"注意"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[t._v("#")]),t._v(" 注意")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("在应用开发中一般不用context, 一般都它的封装react插件\n")])])]),a("hr"),t._v(" "),a("h2",{attrs:{id:"_6-组件优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-组件优化"}},[t._v("#")]),t._v(" 6. 组件优化")]),t._v(" "),a("h3",{attrs:{id:"component的2个问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#component的2个问题"}},[t._v("#")]),t._v(" Component的2个问题")]),t._v(" "),a("blockquote",[a("ol",[a("li",[a("p",[t._v("只要执行setState(),即使不改变状态数据, 组件也会重新render()")])]),t._v(" "),a("li",[a("p",[t._v("只当前组件重新render(), 就会自动重新render子组件 ==> 效率低")])])])]),t._v(" "),a("h3",{attrs:{id:"效率高的做法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#效率高的做法"}},[t._v("#")]),t._v(" 效率高的做法")]),t._v(" "),a("blockquote",[a("p",[t._v("只有当组件的state或props数据发生改变时才重新render()")])]),t._v(" "),a("h3",{attrs:{id:"原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[t._v("#")]),t._v(" 原因")]),t._v(" "),a("blockquote",[a("p",[t._v("Component中的shouldComponentUpdate()总是返回true")])]),t._v(" "),a("h3",{attrs:{id:"解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决"}},[t._v("#")]),t._v(" 解决")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("办法1: \n\t重写shouldComponentUpdate()方法\n\t比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false\n办法2:  \n\t使用PureComponent\n\tPureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true\n\t注意: \n\t\t只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false  \n\t\t不要直接修改state数据, 而是要产生新数据\n项目中一般使用PureComponent来优化\n")])])]),a("hr"),t._v(" "),a("h2",{attrs:{id:"_7-render-props"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-render-props"}},[t._v("#")]),t._v(" 7. render props")]),t._v(" "),a("h3",{attrs:{id:"如何向组件内部动态传入带内容的结构-标签"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何向组件内部动态传入带内容的结构-标签"}},[t._v("#")]),t._v(" 如何向组件内部动态传入带内容的结构(标签)?")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("Vue中: \n\t使用slot技术, 也就是通过组件标签体传入结构  <AA><BB/></AA>\nReact中:\n\t使用children props: 通过组件标签体传入结构\n\t使用render props: 通过组件标签属性传入结构, 一般用render函数属性\n")])])]),a("h3",{attrs:{id:"children-props"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#children-props"}},[t._v("#")]),t._v(" children props")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("<A>\n  <B>xxxx</B>\n</A>\n{this.props.children}\n问题: 如果B组件需要A组件内的数据, ==> 做不到 \n")])])]),a("h3",{attrs:{id:"render-props"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render-props"}},[t._v("#")]),t._v(" render props")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("<A render={(data) => <C data={data}></C>}></A>\nA组件: {this.props.render(内部state数据)}\nC组件: 读取A组件传入的数据显示 {this.props.data}         \n")])])]),a("hr"),t._v(" "),a("h2",{attrs:{id:"_8-错误边界"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-错误边界"}},[t._v("#")]),t._v(" 8. 错误边界")]),t._v(" "),a("h4",{attrs:{id:"理解-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#理解-2"}},[t._v("#")]),t._v(" 理解：")]),t._v(" "),a("p",[t._v("错误边界：用来捕获后代组件错误，渲染出备用页面")]),t._v(" "),a("h4",{attrs:{id:"特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点：")]),t._v(" "),a("p",[t._v("只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误")]),t._v(" "),a("h5",{attrs:{id:"使用方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用方式"}},[t._v("#")]),t._v(" 使用方式：")]),t._v(" "),a("p",[t._v("getDerivedStateFromError配合componentDidCatch")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 生命周期函数，一旦后台组件报错，就会触发")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getDerivedStateFromError")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("error"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在render之前触发")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回新的state")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("hasError")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidCatch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("error"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" info")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 统计页面的错误。发送请求发送到后台去")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("error"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" info"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"_9-组件通信方式总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-组件通信方式总结"}},[t._v("#")]),t._v(" 9. 组件通信方式总结")]),t._v(" "),a("h4",{attrs:{id:"方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方式"}},[t._v("#")]),t._v(" 方式：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("\tprops：\n\t\t(1).children props\n\t\t(2).render props\n\t消息订阅-发布：\n\t\tpubs-sub、event等等\n\t集中式管理：\n\t\tredux、dva等等\n\tconText:\n\t\t生产者-消费者模式\n")])])]),a("h4",{attrs:{id:"组件间的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件间的关系"}},[t._v("#")]),t._v(" 组件间的关系")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("\t父子组件：props\n\t兄弟组件(非嵌套组件)：消息订阅-发布、集中式管理\n\t祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(用的少)\n")])])]),a("h2",{attrs:{id:"_10-usecallback-usememo-memo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-usecallback-usememo-memo"}},[t._v("#")]),t._v(" 10.useCallback,useMemo,memo")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function App (){\n\tconst [num,setNum] = useState(0)\n\tconst myFun = ()=>{\n        console.log('@@')\n\t}\n    return (\n    \t<>\n    \t\t<div>{num}</div>\n    \t\t<button onClick={()=>setNum(num+1)}></button>\n    \t\t<A  myFun={myFun}/>\n    \t</>\n    )\n}\n\nfunction A = {\n    return(\n    \t<>\n    \t\t<div>this is componentA</div>\n    \t</>\n    )\n}\n\n1.若不进行处理，App中每次修改num时也会对A进行重新渲染。处理方式为：\n\tconst A = memo(A);\n2.当 函数作为props 传入到A中时，若即使使用memo进行了处理，App中每次修改num，A组件也会重新渲染。\n\t这时的处理方式为：\n\tconst myFun = useCallback(()=>{\n        console.log('@@')\n\t},[XXX]);\n\tXXX即为依赖项，当xxx进行变化时，就会重新调用函数，来渲染A组件。\n3. 当对一个数进行复杂运算时，且这个数只依赖于某个数，这时使用useMemo来处理。\n\t\n\tconst memoNum = useMemo(()=>{\n        return num*1000\n\t},[num]) ;  // 即表示memoNum 只依赖于num进行更新，其它的数据更新不影响memoNum。\n\t\n\t\n\t\n\n")])])]),a("h2",{attrs:{id:"_11-getderivedstatefromprops"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-getderivedstatefromprops"}},[t._v("#")]),t._v(" 11.getDerivedStateFromProps")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\nstatic getDerivedStateFromProps(props, state)\ngetDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。\n\n此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。\n")])])]),a("h2",{attrs:{id:"_12-getsnapshotbeforeupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-getsnapshotbeforeupdate"}},[t._v("#")]),t._v(" 12. getSnapshotBeforeUpdate")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  getSnapshotBeforeUpdate(prevProps, prevState) {\n   \n    return 'aaa';\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n\t// snapshot = 'aaa'\n\t// snapshot 就是getSnapshotBeforeUpdate 返回的值\n  }\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);